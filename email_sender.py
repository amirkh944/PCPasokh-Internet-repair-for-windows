import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email import encoders
import json
import os

class EmailSender:
    def __init__(self):
        self.config_file = "email_config.json"
        self.load_config()
    
    def load_config(self):
        """Load email configuration from file"""
        default_config = {
            "smtp_server": "smtp.gmail.com",
            "smtp_port": 587,
            "email": "",
            "password": "",
            "recipient": ""
        }
        
        if os.path.exists(self.config_file):
            try:
                with open(self.config_file, 'r') as f:
                    self.config = json.load(f)
            except:
                self.config = default_config
        else:
            self.config = default_config
            self.save_config()
    
    def save_config(self):
        """Save email configuration to file"""
        with open(self.config_file, 'w') as f:
            json.dump(self.config, f, indent=4)
    
    def update_config(self, smtp_server, smtp_port, email, password, recipient):
        """Update email configuration"""
        self.config.update({
            "smtp_server": smtp_server,
            "smtp_port": smtp_port,
            "email": email,
            "password": password,
            "recipient": recipient
        })
        self.save_config()
    
    def send_report(self, report_content, report_file_path=None):
        """Send diagnostic report via email"""
        try:
            if not all([self.config["email"], self.config["password"], self.config["recipient"]]):
                return False, "Email configuration incomplete"
            
            # Create message
            msg = MIMEMultipart()
            msg['From'] = self.config["email"]
            msg['To'] = self.config["recipient"]
            msg['Subject'] = f"Network Diagnostic Report - {self.get_timestamp()}"
            
            # Add body
            body = f"""
Network Diagnostic Report

This report was automatically generated by the Network Troubleshooter application.

Report Details:
{report_content}

---
Generated by Network Troubleshooter App
            """
            
            msg.attach(MIMEText(body, 'plain', 'utf-8'))
            
            # Attach report file if provided
            if report_file_path and os.path.exists(report_file_path):
                with open(report_file_path, "rb") as attachment:
                    part = MIMEBase('application', 'octet-stream')
                    part.set_payload(attachment.read())
                
                encoders.encode_base64(part)
                part.add_header(
                    'Content-Disposition',
                    f'attachment; filename= network_report.txt'
                )
                msg.attach(part)
            
            # Send email
            server = smtplib.SMTP(self.config["smtp_server"], self.config["smtp_port"])
            server.starttls()
            server.login(self.config["email"], self.config["password"])
            text = msg.as_string()
            server.sendmail(self.config["email"], self.config["recipient"], text)
            server.quit()
            
            return True, "Report sent successfully"
            
        except Exception as e:
            return False, f"Failed to send email: {str(e)}"
    
    def test_connection(self):
        """Test email server connection"""
        try:
            if not all([self.config["email"], self.config["password"]]):
                return False, "Email credentials not configured"
            
            server = smtplib.SMTP(self.config["smtp_server"], self.config["smtp_port"])
            server.starttls()
            server.login(self.config["email"], self.config["password"])
            server.quit()
            
            return True, "Email connection successful"
            
        except Exception as e:
            return False, f"Email connection failed: {str(e)}"
    
    def get_timestamp(self):
        """Get current timestamp"""
        from datetime import datetime
        return datetime.now().strftime('%Y-%m-%d %H:%M:%S')